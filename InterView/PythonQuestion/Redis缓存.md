[TOC]



# redis应用场景，缓存的各种问题



### 缓存

redis还有另外一个重要的应用领域——缓存

引用来自网友的图解释缓存在架构中的位置

默认情况下，我们的服务架构如下图，客户端请求service，然后service去读取mysql数据库

[![avatar](assets/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d38613764643439353766666365353532663039353032616432656238366439385f68642e6a7067.jpg)](https://camo.githubusercontent.com/3a7253aca79076b081de3999f284bc26917beff0/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d38613764643439353766666365353532663039353032616432656238366439385f68642e6a7067)

问题存在于，数据库性能不够用，数据库是整个架构中最重要的一个环节，它在高并发，高写入频次的时候非常容易崩掉，这是一般的数据库本身的特性所决定的，它们的架构模式注定了不可以承受较大的并发量，所以就有了缓存：

[![avatar](assets/68747470733a2f2f706963342e7a68696d672e636f6d2f38302f76322d32376537373934383432366436336464666334363431636362316561386165625f68642e6a7067.jpg)](https://camo.githubusercontent.com/272f3c1210eede9fed1e850855ef1957f81cd59d/68747470733a2f2f706963342e7a68696d672e636f6d2f38302f76322d32376537373934383432366436336464666334363431636362316561386165625f68642e6a7067)

service与高速的缓存进行交互，如果缓存中有数据直接返回客户端，如果没有才会从MySql中去查询。减小数据库的压力，提升效率，避免宕机。

例如上面章节提到的，超卖问题，有可能瞬间的流量高达上万，我们不可能把这些请求都响应到数据库上，这样速度慢不说，还随时可能宕机。

提到缓存，就不得不说下面的四大缓存名场面，几乎是做缓存必须面对的问题。

### 缓存击穿

想象一个场景，现在在一个xx办事大厅

张三、李四、王五、赵六、钱钱、刘八、陈九 七个人正在排队

办事处有一个窗口，有一些自动业务机，窗口里面的同志一下子只能接待一个人，而自动业务机因为速度很快可以很快接待很多人。

现在，突然、自动业务机都坏了... 所有人都排到了窗口，这下忙死了窗口里面的同志，直接撂挑子不干了！

这个例子中，自动业务机就像是缓存，起了一个缓冲的作用，业务员就像是数据库，处理能力比自动机器慢，而且很容易炸毛。

缓存击穿就是这样，当某个缓存故障、或者在高峰期缓存突然无效了，就会导致所有请求都跑到数据库去排队，就造成了缓存击穿。

 

缓存相当于给数据库加了一层保护能量罩，敌人进来的时候如果某个地方没有能量，那么如果这个地方的敌人特别多，就会导致缓存击穿。当从缓存中查询不到我们需要的数据就要去数据库中查询了。如果被黑客利用，或者高峰流量，频繁去访问缓存中没有的数据，那么缓存就失去了存在的意义，瞬间所有请求的压力都落在了数据库上，这样会导致数据库连接异常。

解决方案：

- 后台设置定时任务，主动的去更新缓存数据。这种方案容易理解,就是在自动业务机旁边加了一个维护员，坏了赶紧修好，但是机器多了就比较复杂，维护员不一定能搞得定，当key比较分散的时候，操作起来还是比较复杂的
- 分级缓存。什么意思呢，就是放两台业务机器，平时用第一台，第一台坏了马上用第二台，用第二台的时候修第一台，设置两层缓存保护层，1级缓存失效时间短，2级缓存失效时间长。有请求过来优先从1级缓存中去查找，如果在1级缓存中没有找到相应数据，则对该线程进行加锁，这个线程再从数据库中取到数据，更新至1级和2级缓存。其他线程则直接从2级线程中获取

### 缓存穿透

缓存穿透本质上和缓存击穿所面临的问题一样，大量请求落到数据库中。

但是出发点略有不用，缓存穿透的问题是，在高并发下，查询一个不存在的值时，缓存不会被命中，导致大量请求直接落到数据库上，如活动系统里面查询一个不存在的活动。

也就是说，缓存击穿是当数据是存在的，但没有被缓存到，而缓存穿透是去访问根本不存在的值。想象一个场景，黑客截取了一个已经过期的活动的数据接口，然后不断的去请求它，这时候有可能因为这个活动本身已经过期了，缓存不会命中，请求就全部落地到数据库了，这时候就造成了缓存穿透。

缓存穿透的问题解决方案也有很多

直接缓存NULL值

这个比较容易理解，就算是没数据我也缓存一下，你下次过来命中的是空数据。

这种方法需要特别注意，为空的值不能缓存的太久，否则有可能在真的有数据的时候影响了业务正常流程。

布隆过滤器

*什么是布隆过滤器*

布隆过滤器判断一个值不存在，那么这个值100%不存在

布隆过滤器判断一个值存在，这个值90%是存在的

布隆过滤器本质是一个位数组，位数组就是数组的每个元素都只占用 1 bit 。每个元素只能是 0 或者 1。这样申请一个 10000 个元素的位数组只占用 10000 / 8 = 1250 B 的空间。布隆过滤器除了一个位数组，还有 K 个哈希函数。

等一下，是不是有点绕，不太好理解。

我们知道hash函数可以根据一个值生成一个对应的数字，然后与一个长度可以取模可以得到一个下标值 （你不知道？看看HashMap的实现吧）

或者你根本不知道hash是怎么实现的，没关系，也可以先理解下面的，我们先把这个函数假设为 int getIndex (String value)， 根据值获取到一个下标

假设我们现在有一个数组，长度是5，每个元素的值都是0

0 , 0 , 0 , 0 , 0

现在我们数据库中一共有五个id

a , b , c , d , e

现在我们对id们执行getIndex函数可以得到

getIndex(a) = 0

getIndex(b) = 1

getIndex(c) = 1 // 假设函数有一些误差

getIndex(d) = 2

getIndex(e) = 3

想一想，现在来了一个新元素，f 怎么样判断在id里面存在不存在呢？

我们把开始的数组和getIndex关联起来, 将getindex的值作为下标，设置值为1，数组就会变成

1 , 1 , 1 , 1 , 0

然后我们再来判断f是否存在，假设 getIndex(f) = 4

ok了，我们只需要判断数组里的下标4是否是1，是1就存在，0就不存在了嘛

那如果 getIndex(f) = 2 呢？ 我们开了上帝视角，很明显f不存在呀。

布隆过滤器不能100%判断一个元素是否真的存在数组中，但能100%判断它不存在与数组中，这取决于hash函数的算法程度

*布隆过滤器防止缓存穿透*

通过对布隆过滤器的理解，我们能就过滤掉大部分的无效请求了，把数据库中所有的id都getindex解析一次放到布隆过滤器中，请求过来的时候判断，如果不存在就直接返回空就行了

### 缓存雪崩

如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。

其实与缓存击穿的理论差不多，都是突然失效导致的击穿数据库。

雪崩与击穿的不同点在于雪崩强调集中失效两个字

想象～ 我现在有三个缓存key存在redis中，过期时间是一天

一天后，由于key有可能是同时设置的缓存，导致这三个key同时失效了，即使我的缓存击穿问题已经解决，这时候因为集中的key失效，也会造成击穿！，这是量级发生了改变，就像x和y的关系， x表示key的多少，y表示请求的多少。。。

解决方案

- 设置不同的过期时间

热度数据

- 你永远不可能每个缓存都能命中的。什么是好的缓存策略，好的缓存策略是能够识别热点数据，并在热点被读取的时候能够保证命中，这是一个好的缓存策略所必须的条件之一。

### 缓存一致性

数据库的数据和缓存的数据是不可能一致的，数据分为最终一致和强一致两类。

强一致 不可以使用缓存

缓存能做的只能保证数据的最终一致性。

我们能做的只能是尽可能的保证数据的一致性。

不管是先删库再删缓存 还是 先删缓存再删库，都可能出现数据不一致的情况，因为读和写操作是并发的，我们没办法保证他们的先后顺序。

具体应对策略根据业务需求来制订。



### 缓存过期和淘汰

Redis设置的过期时间。这个key过期时是怎么删除的？

Redis采用的是定期删除，注意不是定时删除，不可能为每一个key做一个定时任务去监控删除，这样会耗尽服务器资源。

默认是每100ms检测一次，遇到过期的key则进行删除，这里的检测也不是顺序检测，而是随机检测。

另外为了防止有漏网之鱼，例如在100ms检查的中间间隙，某个key过期，但同时key访问又进来了，这时触发 惰性删除策略 redis会在读取时判断是否已经过期，过期则直接删除。

内存淘汰是指一部分key在内存不够用的情况下会被Redis自动删除，从而会出现从缓存中查不到数据的情况。

例如我们的服务器内存为2G、但是随着业务的发展缓存的数据已经超过2G了。但是这并不能影响我们程序的运行。所以redis会从key列表中抽取一定的热度低的数据进行淘汰策略，腾出空间存储新的key



### 缓存 - 聊聊 Redis 使用场景

- 缓存
- 会话缓存
- 时效性
- 访问频率
- 计数器
- 社交列表
- 记录用户判定信息
- 交集、并集和差集
- 热门列表与排行榜
- 最新动态
- 消息队列





### redis应用场景及实例

前言

Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。在这篇文章中，我们将阐述 Redis 最常用的使用场景，以及那些影响我们选择的不同特性。

- **Redis 的 5 个常见使用场景**

**1、会话缓存（Session Cache）**

最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？

幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。

**2、全页缓存（FPC）**

除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。

再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。

此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

**3、队列**

Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。

如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。

**4、排行榜/计数器**

Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：

当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：

ZRANGE user_scores 0 10 WITHSCORES

Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。

**5、发布/订阅**

最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。

Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。

详解 Redis 应用场景及应用实例





### 如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：

1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。

2 、Redis支持数据的备份，即master-slave模式的数据备份。

3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

\2. Redis常用数据类型

Redis最为常用的数据类型主要有以下：

String

Hash

List

Set

Sorted set

pub/sub

Transactions

在具体描述这几种数据类型之前，我们先通过一张图了解下Redis内部内存管理中是如何描述这些不同数据类型的：

 ![redis应用场景及实例](assets/o4YBAFp9R8WATVA0AAGAcUDOyP0347.png)

首先Redis内部使用一个redisObject对象来表示所有的key和value，redisObject最主要的信息如上图所示：

type代表一个value对象具体是何种数据类型，

encoding是不同数据类型在redis内部的存储方式，

比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，如果是int则代表实际 redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如：”123″ “456″这样的字符串。

这里需要特殊说明一下vm字段，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的，该功能会在后面具体描述。通过上图我们可以发现Redis使用redisObject来表示所有的key/value数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用，我们随后会具体讨论。